;; -*- Mode:Lisp; Syntax:ANSI-Common-LISP; Coding:us-ascii-unix; fill-column:158 -*-
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;; @file      use-fsamp.lisp
;; @author    Mitch Richling <https://www.mitchr.me>
;; @brief     Sample mathematical functions and create DQUADs and DSIMPs.@EOL
;; @std       Common Lisp
;; @copyright
;;  @parblock
;;  Copyright (c) 1991, 1992, 1994, 1997, 2008, 2015, Mitchell Jay Richling <https://www.mitchr.me> All rights reserved.
;;
;;  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
;;
;;  1. Redistributions of source code must retain the above copyright notice, this list of conditions, and the following disclaimer.
;;
;;  2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions, and the following disclaimer in the documentation
;;     and/or other materials provided with the distribution.
;;
;;  3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software
;;     without specific prior written permission.
;;
;;  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;;  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;;  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
;;  OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
;;  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
;;  DAMAGE.
;;  @endparblock
;; @todo      Smooth function -- returns derivative info.  Include derivative info, normal vectors, etc... in dquad@EOL@EOL
;; @todo      Adaptive 2D/3D functions with data stored in binary quadrilateral trees@EOL@EOL
;; @todo      Adaptive 2D functions on triangular meshes.@EOL@EOL
;; @todo      Use MXP for functions in algebraic notation.@EOL@EOL
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defpackage :MJR_FSAMP
  (:USE :COMMON-LISP
        :MJR_VVEC
        :MJR_NUMU
        :MJR_COMBC
        :MJR_GEOM
        :MJR_ARR
        :MJR_UTIL
        :MJR_DQUAD
        :MJR_DSIMP
        :MJR_POLY)
  (:DOCUMENTATION "Brief: Sample functions and store structured data.;")
  (:EXPORT #:mjr_fsamp_help
           ;; Real and complex polynomials
           #:mjr_fsamp_dq-poly-r1
           #:mjr_fsamp_dq-poly-c1
           ;; Generic real functions: $f:\mathbb{R}^n\to\mathbb{R}^m$ with $m,n\in\{1,2,3\}$
           #:mjr_fsamp_dq-func-r123-r123
           #:mjr_fsamp_dq-func-r123-color
           #:mjr_fsamp_ds-func-r123-r123
           ;; Generic complex functions: $f:\mathbb{C}\to\mathbb{C}$
           #:mjr_fsamp_dq-func-c1-c1
           ;; Specialized sampling for complex functions
           #:mjr_fsamp_dq-complex-circle-image
           #:mjr_fsamp_dq-complex-circle-image-mag
           #:mjr_fsamp_dq-mahler-samp
           ;; Specialized adaptive sampling for real functions
           #:mjr_fsamp_ds-func-r1-rn-adaptive
           ))

(in-package :MJR_FSAMP)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun mjr_fsamp_help ()
  "Help for MJR_FSAMP:  Function SAMPle -- sample mathematical functions and store results DQUAD, DSIMP, and BQTREE objects

Naming conventions: 
   * mjr_fsamp_dq-* -- work with DQUAD
   * mjr_fsamp_ds-* -- work with DSIMP
   * mjr_fsamp_bq-* -- work with BQTREE

In practice DQUAD lists are frequently generated by sampling mathematical functions on a regular gird, and DSIMP lists are
frequently created from the DQUADs produced in this way.  This package is intended to make this process as simple as possible."
  (documentation 'mjr_fsamp_help 'function))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun mjr_fsamp_dq-func-c1-c1 (f &key rdat idat f_color z_color zf_color)

  "Return a dquad list containing data useful for complex function visualization.

The returned dquad list will contain the following (in this order today, but use the data names in case the order changes):
  - AXIS: real     -- Re(z)
  - AXIS: imag     -- Im(z)
  - DATA: z        -- A complex value in the domain.  When exported to VTK, this will yield two scalar values: z_real & z_imag
  - DATA: f        -- f(z)                            When exported to VTK, this will yield two scalar values: f_real & f_imag
  - DATA: f_abs    -- abs(f(z))
  - DATA: f_phase  -- arg(f(z))
  - DATA: z_color  -- z_color(z)                      Must return :cs-rgb colors See use-colorize.lisp and use-colorizer.lisp
  - DATA: f_color  -- f_color(f(z))                   Must return :cs-rgb colors See use-colorize.lisp and use-colorizer.lisp
  - DATA: zf_color -- zf_color(z, f(z))               Must return :cs-rgb colors See use-colorize.lisp and use-colorizer.lisp

  Note: Some tools will only use one color scalar in a data set

Example:
  * (mjr_gnupl_dquad (mjr_fsamp_dq-func-c1-c1 #'sin
                                              :rdat '(:start -1.5d0 :end 1.5d0 :len 50)
                                              :idat '(:start -1.5d0 :end 1.5d0 :len 50))
                     :data \"f_abs\" :type :f)"
  (let* (;;(c-func  (mjr_mxp_string-or-func-to-lambda c-func "Z"))
         ;;(f       (mjr_mxp_string-or-func-to-lambda f      "Z"))
         (daDquad (mjr_dquad_make-from-axis "real" rdat
                                            "imag" idat)))
    (mjr_dquad_add-data-from-map daDquad #'complex    :axes 't     :ano-nam "z"        :ano-typ :ano-typ-complex)
    (mjr_dquad_add-data-from-map daDquad f            :data 0      :ano-nam "f"        :ano-typ :ano-typ-complex)
    (mjr_dquad_add-data-from-map daDquad #'abs        :data 1      :ano-nam "f_abs"    :ano-typ :ano-typ-real)
    (mjr_dquad_add-data-from-map daDquad #'phase      :data 1      :ano-nam "f_phase"  :ano-typ :ano-typ-real)
    (if z_color
        (mjr_dquad_add-data-from-map daDquad z_color  :data 0      :ano-nam "z_color"  :ano-typ :ano-typ-rgbvec))
    (if zf_color
        (mjr_dquad_add-data-from-map daDquad zf_color :data '(0 1) :ano-nam "zf_color" :ano-typ :ano-typ-rgbvec))
    (if f_color
        (mjr_dquad_add-data-from-map daDquad f_color  :data 1      :ano-nam "f_color"  :ano-typ :ano-typ-rgbvec))
    daDquad))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun mjr_fsamp_dq-poly-c1 (poly &key rdat idat f_color z_color zf_color do-log)
  "Use MJR_FSAMP_DQ-FUNC-C1-C1 to sample the polynomial POLY

Examples:
  * (mjr_gnupl_dquad (mjr_fsamp_dq-poly-c1 #(1 0 0 1) :rdat '(:start -1.5d0 :end 1.5d0 :len 50) :idat '(:start -1.5d0 :end 1.5d0 :len 50))
                     :data \"f_abs\" :type :f)
  * Lehmer's polynomial:
    (mjr_gnupl_dquad (mjr_fsamp_dq-poly-c1 #(1 0 -1 1 0 -1 0 1 -1 0 1)
                                           :rdat '(:start -1.5d0 :end 1.5d0 :len 150)
                                           :idat '(:start -1.5d0 :end 1.5d0 :len 150)
                                           :do-log 't)
                     :data \"f_abs\"
                     :type :f)"
  (mjr_fsamp_dq-func-c1-c1 (if do-log
                               (lambda (z) (log (mjr_poly_eval poly z)))
                               (lambda (z) (mjr_poly_eval poly z)))
                           :rdat rdat
                           :idat idat
                           :f_color f_color
                           :z_color z_color
                           :zf_color zf_color))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun mjr_fsamp_dq-poly-r1 (poly-olos &key (order 0) (xdat '(:start -1 :end 1 :len 10)) (ylab "p") (xlab "x"))
  "Construct dquad with values from polynomial and ORDER derivatives evaluated on :xdat

If ylab is 'p' and the xlab is 'x', then 1) the polynomial :ano-nam will be p(x) and 2) the derivative :ano-nam values will look
like 'd^{n}p(x)/dx^{n}.

Examples:
  * (mjr_gnupl_dquad (mjr_fsamp_dq-poly-r1 #(2310 -7201 8949 -5541 1709 -210) :order 2 :xdat '(:start 0.45L0 :end 0.75L0 :len 1000))
                     :data '(0 1) :type :l :ylim '(-0.002 0.015))
  * (mjr_gnupl_dquad (mjr_fsamp_dq-poly-r1 #(1 0 -1 1 0 -1 0 1 -1 0 1) :order 4 :xdat '(:start -1.45d0 :end 1.25d0 :len 2000))
                     :data '(0 1) :type :l :ylim '(-2 6))"
  (let* ((list-of-poly  (mjr_util_non-list-then-list poly-olos))
         (num-polys     (length list-of-poly))
         (list-of-order (typecase order
                          (integer   (loop repeat num-polys
                                           collect order))
                          (list      order)
                          (otherwise (error "mjr_fsamp_dq-poly-r1: The order parameter must be an integer or list of intgers"))))
         (list-of-ylab  (typecase ylab
                          (string    (if (= 1 num-polys)
                                         (list ylab)
                                         (loop for i from 1 upto num-polys
                                               collect (format nil "~a_{~d}" ylab i))))
                          (list      ylab)
                          (otherwise (error "mjr_fsamp_dq-poly-r1: The ylab parameter must be a string or list of strings")))))
    (cond ((not (= (length list-of-poly) (length list-of-order))) (error "mjr_fsamp_dq-poly-r1: poly-olos order length mismatch"))
          ((not (= (length list-of-poly) (length list-of-ylab)))  (error "mjr_fsamp_dq-poly-r1: poly-olos ylab length mismatch")))
    (let* ((xdat      (mjr_vvec_to-vec xdat))
           (new-dquad (mjr_dquad_make-from-axis xlab xdat)))
      (loop for i from 1 upto num-polys
            for order in list-of-order
            for poly in list-of-poly
            for ylab in list-of-ylab
            do (mjr_dquad_add-multi-data new-dquad
                                         (mjr_combc_gen-all-cross-product (list xdat)
                                                                          :collect-value (lambda (x) (multiple-value-list
                                                                                                      (mjr_poly_eval-poly-and-first-n-derivatives poly x order)))
                                                                          :arg-mode :arg-number
                                                                          :result-type :array)
                                         :ano-typ :ano-typ-real
                                         :ano-nam-olos (loop for o from 0 upto order
                                                             collect (if (zerop o)
                                                                         (format nil "~a(~a)" ylab xlab)
                                                                         (format nil "d^{~d}~a(~a)/d~a^{~d}" o ylab xlab xlab o)))))
      new-dquad)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun mjr_fsamp_dq-func-r123-color (color-func-olos &key (func-lab "c") (ano-typ :ano-typ-rgbvec) xdat ydat zdat (arg-mode :arg-number) (xlab "x") (ylab "y") (zlab "z"))
  "Transform one or more color functions (i.e. a function returning a color when given 1, 2, or 3 real arguments) into a DQUAD"
  (flet ((mkLabs (labs num) ;; Create NUM unique labels from list of labels in LABS
           (if (<= num (length labs))
               labs
               (let ((good-labs nil))
                 (loop for i from 0 upto (1- num)
                       for b = (mjr_util_elt-mod labs i)
                       do (loop for j from 0
                                for n = (format nil "~a~d" b j)
                                when (not (member n good-labs :test #'string=))
                                return (push n good-labs))
                       finally (return (reverse good-labs)))))))
    (let* ((list-of-funcs     (mjr_util_non-list-then-list color-func-olos))
           (list-of-ano-typs  (mjr_util_non-list-then-list ano-typ))
           (list-of-func-labs (mkLabs (mjr_util_non-list-then-list func-lab) (length list-of-funcs))))
      (cond ((zerop (length list-of-funcs))         (error "mjr_fsamp_dq-func-r123-color: FUNC must be provided!"))
            ((not xdat)                             (error "mjr_fsamp_dq-func-r123-color: XDAT must be provided!"))
            ((and zdat (not ydat))                  (error "mjr_fsamp_dq-func-r123-color: YDAT must be provided when ZDAT is provided!")))
      (let ((daDquad (apply #'mjr_dquad_make-from-axis (append (list xlab xdat) (if ydat (list ylab ydat)) (if zdat (list zlab zdat))))))
        (loop for i from 0
              for f in list-of-funcs
              for d-lab in list-of-func-labs
              for d = (mjr_dquad_map daDquad f :axes 't :arg-mode arg-mode)
              for d-val = (mjr_arr_aref-row-major d 0)
              for d-typ = (mjr_util_elt-mod list-of-ano-typs i)
              do (mjr_dquad_add-data daDquad d :ano-nam d-lab :ano-typ d-typ))
        daDquad))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun mjr_fsamp_dq-func-r123-r123 (func-olos &key
                                                (func-lab "f")
                                                xdat ydat zdat (arg-mode :arg-number) (xlab "x") (ylab "y") (zlab "z")
                                                ax-color-meth  ax-color-max-color  (ax-color-lab  "c") (ax-color-auto-scale  't) (ax-color-ano-typ  :ano-typ-rgbvec)
                                                f-color-meth   f-color-max-color   (f-color-lab   "c") (f-color-auto-scale   't) (f-color-ano-typ   :ano-typ-rgbvec)
                                                all-color-meth all-color-max-color (all-color-lab "c") (all-color-auto-scale 't) (all-color-ano-typ :ano-typ-rgbvec))
  "Transform one or more mathematical functions into a dquad
     Arguments:
       - func-olos .. A function or list of same
       - func-lab .............. Labels (names) for functions
       - xdat ydat zdat ........ VVECs that define the domain
       - xlab ylab zlab ........ Labels (names) for domain axes (xdat, ydat, and zdat)
       - arg-mode .............. How args are passed to the functions.  May be a list
       - u-close v-close ....... For :dsimp output.  Close the curve or surface
       - X-color-lab ........... Labels (names) for *-color-meth
       - X-color-meth .......... color-method or list of same.  See: MJR_COLORIZE_MAKE-COLORIZE-FUNCTION
       - X-color-ano-typ ....... :ano-typ or list of same.  See: :MJR_ANNOT and MJR_COLORIZE_MAKE-COLORIZE-FUNCTION
       - X-color-auto-scale .... auto-scale or list of same.  See: MJR_COLORIZE_MAKE-COLORIZE-FUNCTION
       - X-color-max-color ..... max-color or list of same.  MJR_See: COLORIZE_MAKE-COLORIZE-FUNCTION
                           -  X=ax .... axis              -- color functions receive x, y, z
                           -  X=f ..... function          -- color functions receive f0, ..., n_{n-1}
                           -  X=all ... axis and function -- color functions receive x, y, z, f0, ..., n_{n-1})
     Examples:
      * Single rectilinear function graph (curve)
       (let ((data (mjr_fsamp_dq-func-r123-r123 #'sin
                                                :xdat '(:start 0 :end 7 :len 100))))
            (mjr_gnupl_dquad data :data 0 :type :l))
      * Single rectilinear univariate polynomial graph (curve)
       (let ((data (mjr_fsamp_dq-func-r123-r123 (lambda (x) (mjr_poly_eval #(2310 -7201 8949 -5541 1709 -210) x))
                                                :xdat '(:start 0.45L0 :end 0.75L0 :len 100))))
            (mjr_gnupl_dquad data :data 0 :type :l :ylim '(-0.002 0.015)))
      * Two rectilinear polynomial graph
       (let ((data (mjr_fsamp_dq-func-r123-r123 (list #'sin #'cos) :xdat (list :start (* -2 pi) :end (* 2 pi) :len 100))))
            (mjr_gnupl_dquad data :data '(0 1) :type :l))
      * Single parametric curve plot in 2D
       (let ((data (mjr_fsamp_dq-func-r123-r123 (lambda (x) (vector (sin x) (cos x)))
                                                :xdat (list :start 0 :end (* 2 pi) :len 100))))
            (mjr_gnupl_dquad data :data 0 :type :l))
      * Single parametric curve plot in 3D
       (let ((data (mjr_fsamp_dq-func-r123-r123 (lambda (x) (vector (sin x) (cos x) x))
                                                :xdat (list :start 0 :end (* 2 pi) :len 100))))
            (mjr_gnupl_dquad data :data 0 :type :l))
      * Single rectilinear surface graph
       (let ((data (mjr_fsamp_dq-func-r123-r123 (lambda (x y) (sin (sqrt (+ (* x x) (* y y)))))
                                                :xdat '(:start -7 :end 7 :len 10)
                                                :ydat '(:start -7 :end 7 :len 10))))
            (mjr_gnupl_dquad data :data 0 :type :f))
      * Single 2D image graph
       (let ((data (mjr_fsamp_dq-func-r123-r123 (lambda (x y) (sin (sqrt (+ (* x x) (* y y)))))
                                                :xdat '(:start -7 :end 7 :len 100)
                                                :ydat '(:start -7 :end 7 :len 100))))
            (mjr_gnupl_dquad data :data 0 :type :i))
      * Single parametric surface plot
       (let ((data (mjr_fsamp_dq-func-r123-r123 (lambda (x y)
                                                         (let ((a 1)
                                                               (c 3))
                                                           (vector (* (cos x) (+ c (* a (cos y))))
                                                                   (* (sin x) (+ c (* a (cos y))))
                                                                   (* a (sin y)))))
                                                :xdat '(:start 0 :end 5.0 :len 20)
                                                :ydat '(:start 0 :end 6.0 :len 20))))
                (mjr_gnupl_dquad data :data 0 :type :l))"
  (flet ((mkLabs (labs num) ;; Create NUM unique labels from list of labels in LABS
           (if (<= num (length labs))
               labs
               (let ((good-labs nil))
                 (loop for i from 0 upto (1- num)
                       for b = (mjr_util_elt-mod labs i)
                       do (loop for j from 0
                                for n = (format nil "~a~d" b j)
                                when (not (member n good-labs :test #'string=))
                                return (push n good-labs))
                       finally (return (reverse good-labs)))))))
    (let* ((list-of-funcs           (mjr_util_non-list-then-list func-olos))
           (list-of-func-labs       (mkLabs (mjr_util_non-list-then-list func-lab) (length list-of-funcs)))
           (list-of-ax-color-meths  (mjr_util_non-list-then-list ax-color-meth))
           (list-of-ax-color-mc     (mjr_util_non-list-then-list ax-color-max-color))
           (list-of-ax-color-as     (mjr_util_non-list-then-list ax-color-auto-scale))
           (list-of-ax-color-at     (mjr_util_non-list-then-list ax-color-ano-typ))
           (list-of-ax-color-labs   (mkLabs (mjr_util_non-list-then-list ax-color-lab) (length list-of-ax-color-meths)))
           (list-of-f-color-meths   (mjr_util_non-list-then-list f-color-meth))
           (list-of-f-color-mc      (mjr_util_non-list-then-list f-color-max-color))
           (list-of-f-color-as      (mjr_util_non-list-then-list f-color-auto-scale))
           (list-of-f-color-at      (mjr_util_non-list-then-list f-color-ano-typ))
           (list-of-f-color-labs    (mkLabs (mjr_util_non-list-then-list f-color-lab) (length list-of-f-color-meths)))
           (list-of-all-color-meths (mjr_util_non-list-then-list all-color-meth))
           (list-of-all-color-mc    (mjr_util_non-list-then-list all-color-max-color))
           (list-of-all-color-as    (mjr_util_non-list-then-list all-color-auto-scale))
           (list-of-all-color-at    (mjr_util_non-list-then-list all-color-ano-typ))
           (list-of-all-color-labs  (mkLabs (mjr_util_non-list-then-list all-color-lab) (length list-of-all-color-meths))))
      (cond ((zerop (length list-of-funcs))         (error "mjr_fsamp_dq-func-r123-r123: FUNC must be provided!"))
            ((not xdat)                             (error "mjr_fsamp_dq-func-r123-r123: XDAT must be provided!"))
            ((and zdat (not ydat))                  (error "mjr_fsamp_dq-func-r123-r123: YDAT must be provided when ZDAT is provided!")))
      (let ((daDquad (apply #'mjr_dquad_make-from-axis (concatenate 'list (list xlab xdat) (if ydat (list ylab ydat)) (if zdat (list zlab zdat))))))
        (loop for i from 0
              for f in list-of-funcs
              for d-lab in list-of-func-labs
              for d = (mjr_dquad_map daDquad f :axes 't :arg-mode arg-mode)
              for d-val = (mjr_arr_aref-row-major d 0)
              for d-typ = (typecase d-val
                            (complex   :ano-typ-complex)
                            (number    :ano-typ-real)
                            (vector    (typecase (aref d-val 0)
                                         (complex   :ano-typ-cvec)
                                         (number    :ano-typ-rvec)
                                         (otherwise (error "mjr_fsamp_dq-func-r123-r123: Function return type not supported: ~a!" d-val))))
                            (otherwise (error "mjr_fsamp_dq-func-r123-r123: Function return type not supported: ~a!" d-val)))
              do (mjr_dquad_add-data daDquad d :ano-nam d-lab :ano-typ d-typ))
        (if list-of-ax-color-meths
            (loop for i from 0
                  for c-cm  in list-of-ax-color-meths
                  for c-lab in list-of-ax-color-labs
                  for c-as  = (if list-of-ax-color-as (mjr_util_elt-mod list-of-ax-color-as i))
                  for c-at  = (if list-of-ax-color-at (mjr_util_elt-mod list-of-ax-color-at i))
                  for c-mc  = (if list-of-ax-color-mc (mjr_util_elt-mod list-of-ax-color-mc i))
                  do (apply #'mjr_dquad_colorize daDquad :ano-nam c-lab :axes 't (append (if c-cm (list :color-method c-cm))
                                                                                         (if c-as (list :auto-scale   c-as))
                                                                                         (if c-mc (list :max-color    c-mc))))))
        (if list-of-f-color-meths
            (let ((data-idxs (concatenate 'list (mjr_vvec_to-vec (length list-of-funcs)))))

              (loop for i from 0
                    for c-cm  in list-of-f-color-meths
                    for c-lab in list-of-f-color-labs
                    for c-as  = (if list-of-f-color-as (mjr_util_elt-mod list-of-f-color-as i))
                    for c-at  = (if list-of-f-color-at (mjr_util_elt-mod list-of-f-color-at i))
                    for c-mc  = (if list-of-f-color-mc (mjr_util_elt-mod list-of-f-color-mc i))
                    do (apply #'mjr_dquad_colorize daDquad :ano-nam c-lab :data data-idxs (append (if c-cm (list :color-method c-cm))
                                                                                                  (if c-as (list :auto-scale   c-as))
                                                                                                  (if c-mc (list :max-color    c-mc)))))))
        (if list-of-all-color-meths
            (let ((data-idxs (concatenate 'list (mjr_vvec_to-vec (length list-of-funcs)))))
              (loop for i from 0
                    for c-cm  in list-of-all-color-meths
                    for c-lab in list-of-all-color-labs
                    for c-as  = (if list-of-all-color-as (mjr_util_elt-mod list-of-all-color-as i))
                    for c-at  = (if list-of-all-color-at (mjr_util_elt-mod list-of-all-color-at i))
                    for c-mc  = (if list-of-all-color-mc (mjr_util_elt-mod list-of-all-color-mc i))
                    do (apply #'mjr_dquad_colorize daDquad :ano-nam c-lab :axes 't :data data-idxs (append (if c-cm (list :color-method c-cm))
                                                                                                           (if c-as (list :auto-scale   c-as))
                                                                                                           (if c-mc (list :max-color    c-mc)))))))
        daDquad))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun mjr_fsamp_ds-func-r123-r123 (f &key
                                        (func-lab "f")
                                        xdat ydat (arg-mode :arg-number) (xlab "x") (ylab "y")
                                        ax-color-meth  (ax-color-max-color  1) (ax-color-lab  "c") (ax-color-auto-scale  't) (ax-color-ano-typ  :ano-typ-rgbvec)
                                        f-color-meth   (f-color-max-color   1) (f-color-lab   "c") (f-color-auto-scale   't) (f-color-ano-typ   :ano-typ-rgbvec)
                                        all-color-meth (all-color-max-color 1) (all-color-lab "c") (all-color-auto-scale 't) (all-color-ano-typ :ano-typ-rgbvec)
                                        u-close v-close)
  "Transform a mathematical function into a dsimp list
     All arguments are as documented in mjr_fsamp_dq-func-r123-r123, with the following additions:
       - u-close v-close ............ Close the curve or surface"
  (mjr_dsimp_make-from-dquad (mjr_fsamp_dq-func-r123-r123 f
                                                          :xdat xdat :ydat ydat :arg-mode arg-mode :xlab xlab :ylab ylab
                                                          :func-lab func-lab
                                                          :ax-color-meth ax-color-meth :ax-color-max-color
                                                          ax-color-max-color :ax-color-lab ax-color-lab :ax-color-auto-scale
                                                          ax-color-auto-scale :ax-color-ano-typ
                                                          ax-color-ano-typ :f-color-meth f-color-meth :f-color-max-color
                                                          f-color-max-color :f-color-lab f-color-lab :f-color-auto-scale
                                                          f-color-auto-scale :f-color-ano-typ
                                                          f-color-ano-typ :all-color-meth
                                                          all-color-meth :all-color-max-color
                                                          all-color-max-color :all-color-lab
                                                          all-color-lab :all-color-auto-scale
                                                          all-color-auto-scale :all-color-ano-typ all-color-ano-typ)
                             (apply #'list 0 (if ydat (list 1)))
                             0
                             :data 't :u-close u-close :v-close v-close))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun mjr_fsamp_dq-complex-circle-image (func &key (radii 1) (len 3000) (include-circles nil) return-complex)
  "Compute LEN sample points in FUNC(z) for |z|=r for each r in RADII

Arguments:
 * INCLUDE-CIRCLES .. Also compute LEN sample points for the circle |z|=r for each r in RADII
 * RADII ............ May be a single positive real number or a list of same

Examples:
 * (mjr_gnupl_dquad (mjr_fsamp_dq-complex-circle-image #'sin :radii (loop for i from 1 upto 5 by .1 collect i) :len 1000) :main \"Complex Circle Images\")"
  (let ((data     (mjr_dquad_make-from-axis "phase" (list :start 0.0D0 :end (* 2.0d0 pi) :len len)))
        (radii (mjr_util_non-list-then-list radii)))
    (dolist (radius radii)
      (if include-circles
          (mjr_dquad_add-data-from-map data
                                       (lambda (a) (if return-complex
                                                       (complex (* radius (cos a)) (* radius (sin a)))        ;; (exp (* i a))
                                                       (vector  (* radius (cos a)) (* radius (sin a)))))
                                       :axes 0
                                       :ano-nam (format nil "c=~a" radius)
                                       :ano-typ :ano-typ-rvec))
      (mjr_dquad_add-data-from-map data
                                   (lambda (a) (let ((v (funcall func (complex (* radius (cos a)) (* radius (sin a))))))
                                                 (if return-complex
                                                     v
                                                     (mjr_numu_complex-to-vector v))))
                                   :axes 0
                                   :ano-nam (format nil "r=~a" radius)
                                   :ano-typ :ano-typ-rvec))
    data))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun mjr_fsamp_dq-complex-circle-image-mag (func &key (radii 1) (len 3000) (do-log 't) (include-circles nil) return-complex (polar 't))
  "Compute LEN sample points of $\exp(i\cdot a)\cdot \vert \mathrm{FUNC}(\mathrm{RADII}\cdot\exp(i\cdot a))\vert$ on $a\in[0,2\pi]$

In other words, we take a point $x+yi$ on the circle $|x+yi|=r$ for $r\in\mathrm{RADII}$, and map it to $(x+yi)\cdot\vert\mathrm{FUNC}(x+yi)\vert$

When FUNC is a polynomial, $r=1$, and DO-LOG is non-NIL, the resulting function is closely related to the Mahler measure:

   $$\ln(M(p))=\frac{1}{2\pi}\int_0^{2\pi}ln(\vert p(e^{i\theta})\vert)\,\mathrm{d}\theta$$

Arguments:
 * INCLUDE-CIRCLES .. Also compute LEN sample points for the circle |z|=r for each r in RADII
 * RADII ............ May be a single positive real number or a list of same
 * DO-LOG ........... Compute the natural logarithm of the magnitude instead of the magnitude.

Examples:
 * (mjr_gnupl_dquad (mjr_fsamp_dq-complex-circle-image-mag #'sin :radii (loop for i from .8 upto .9 by .01 collect i) :len 1000) :main \"Complex Circle Magnitude\")
 * (mjr_gnupl_dquad (mjr_fsamp_dq-complex-circle-image-mag (lambda (z) (mjr_poly_eval #(1 0 -1 1 0 -1 0 1 -1 0 1) z)) :len 4000)            :main \"Mahler Plot\")
 * (mjr_gnupl_dquad (mjr_fsamp_dq-complex-circle-image-mag (lambda (z) (mjr_poly_eval #(1 0 -1 1 0 -1 0 1 -1 0 1) z)) :len 4000 :polar nil) :main \"Mahler Plot\")"
  (cond ((and (not polar) include-circles) (error "mjr_fsamp_dq-complex-circle-image-mag: non-NIL :INCLUDE-CIRCLES requires non-NIL :POLAR may not be used in the same call"))
        )
  (let ((data  (mjr_dquad_make-from-axis "phase" (list :start 0.0D0 :end (* 2.0d0 pi) :len len)))
        (radii (mjr_util_non-list-then-list radii)))
    (dolist (radius radii)
      (if include-circles
          (mjr_dquad_add-data-from-map data
                                       (lambda (a) (if return-complex
                                                       (complex (* radius (cos a)) (* radius (sin a)))
                                                       (vector  (* radius (cos a)) (* radius (sin a)))))
                                       :axes 0
                                       :ano-nam (format nil "c=~a" radius)
                                       :ano-typ :ano-typ-rvec))
      (mjr_dquad_add-data-from-map data
                                   (lambda (a) (let* ((x (* radius (cos a)))
                                                      (y (* radius (sin a)))
                                                      (m (if do-log
                                                             (log (abs (funcall func (complex x y))))
                                                             (abs (funcall func (complex x y))))))
                                                 (if polar
                                                     (if return-complex
                                                         (complex (* m x) (* m y))
                                                         (vector  (* m x) (* m y)))
                                                     m)))
                                   :axes 0
                                   :ano-nam (format nil "r=~a" radius)
                                   :ano-typ (if polar
                                                (if return-complex
                                                    :ano-typ-complex
                                                    :ano-typ-rvec)
                                                :ano-typ-real)))
    data))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun mjr_fsamp_dq-mahler-samp (p &rest rest)
  "Preform complex-circle-image-mag on the polynomial P.

Examples:
 * (mjr_gnupl_dquad (mjr_fsamp_dq-mahler-samp #(1 0 2 0 5/3 0 1 0 -5) :radii (loop for i from 1/6 upto 5/4 by 1/30 collect i) :do-log nil :len 1000) :main \"Mahler Plot\")
 * (mjr_gnupl_dquad (mjr_fsamp_dq-mahler-samp #(1 0 2 0 5/3 0 1 0 -5) :radii (loop for i from 1/6 upto 5/4 by 1/30 collect i) :do-log 't  :len 1000) :main \"Mahler Plot\")
 * (mjr_gnupl_dquad (mjr_fsamp_dq-mahler-samp #(1 0 2 0 5/3 0 1 0 -5) :radii '(5/6 11/10) :do-log 't :len 1000 :include-circles 't)                  :main \"Mahler Plot\")
 * (mjr_gnupl_dquad (mjr_fsamp_dq-mahler-samp #(1 0 -1 1 0 -1 0 1 -1 0 1) :len 4000 :do-log 't  :polar 't ) :main \"Mahler Plot\")
 * (mjr_gnupl_dquad (mjr_fsamp_dq-mahler-samp #(1 0 -1 1 0 -1 0 1 -1 0 1) :len 4000 :do-log nil :polar 't ) :main \"Mahler Plot\")
 * (mjr_gnupl_dquad (mjr_fsamp_dq-mahler-samp #(1 0 -1 1 0 -1 0 1 -1 0 1) :len 4000 :do-log 't  :polar nil) :main \"Mahler Plot\")
 * (mjr_gnupl_dquad (mjr_fsamp_dq-mahler-samp #(1 0 -1 1 0 -1 0 1 -1 0 1) :len 4000 :do-log nil :polar nil) :main \"Mahler Plot\")"
  (apply #'mjr_fsamp_dq-complex-circle-image-mag (lambda (z) (mjr_poly_eval p z)) rest))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun mjr_fsamp_ds-func-r1-rn-adaptive (f initial-mesh &key
                                                          (n                           1)   ;; dimintion of return from f
                                                          (clip-max                    nil) ;; Bounding box minimum. Set to throw out points
                                                          (clip-min                    nil) ;; Bounding box maximm. Set to throw out points
                                                          (fine-mesh-level             10)  ;; Set finest mesh width to (expt 2 fine-mesh-level)/range
                                                          (coarse-mesh-level           4)   ;; Set corsest mesh width to (expt 2 fine-mesh-level)/range
                                                          (max-simplex-length          nil) ;; (max-min)/100
                                                          (min-simplex-length          nil) ;; (max-min)/10000
                                                          (max-bounding-box-width      nil)
                                                          (min-bounding-box-width      nil) ;; May be more usefull than min-simplex-length
                                                          (max-bounding-box-area       nil)
                                                          (cos-join-angle-cutoff       nil) ;; 0.0001d0
                                                          (cos-divergence-angle-cutoff nil) ;; 0.0001d0 => just less than 1 degree
                                                          (h-cutoff-eps                nil) ;; 0.01d0
                                                          (cos-smooth-angle-cutoff     nil) ;; 0.0001d0
                                                          (sandwich-area-cutoff        nil) ;;
                                                          (do-axis-crossing            nil)
                                                          (simplify-mesh-angle         nil) ;; 0.0001d0
                                                          (show-progress               nil))
  "Produce a set of 1-simplexes approximating a function $f:\\mathbb{R}\\rightarrow\\mathbb{R}^n$ using an adaptive algorithm to select sample points.

                                    ******************************************************************
                                    ******************************************************************
                                    ******************************************************************
                                    ***** NOTE: This one is still pretty rough and experimental. *****
                                    ******************************************************************
                                    ******************************************************************
                                    ******************************************************************

On N:
  - N = 1
    - F must return a real number
    - :CLIP-MAX and :CLIP-MIN are numbers
  - N != 1
    - F must return a real vector number
    - :CLIP-MAX and :CLIP-MIN are vectors describing a bounding box (see: MJR_GEOM_BOUNDING-BOX & MJR_GEOM_POINT-INSIDE-BOUNDING-BOX-F?)

Primary Use Case

   Many tools use some form of adaptive sampling to graph a function (Maple, Matlab, Mathematica, Yacas, etc...).  Few of them expose the results or provide
   much flexibility in how the sampling is preformed.  This function is designed to provide several methods of adaptability which may be composed together
   under user control.  The results are a DSIMP object (see MJR_DSIMP) which may be easily used by other tools.  The idea is to enable one to inject a bit of
   human input into the meshing process in order to obtain better results than a fully automatic scheme.  My primary use case is to create publication
   quality, low point count, meshes for inclusion into scaleable documents (PDF & Postscipt via LaTeX), and vector graphics formats (SVG).  My secondary use
   case is high quality, low simplex count, geometry for tools like VisIT, Paraview, PovRay, Meshlab, & Blender.  Other use cases include visualization of
   'method of lines' solutions, slice visualization for high dimensional manifolds, and high quality grid lines for 2D surfaces rendered in PovRay.

Meshing Method

   The initial approximation is computed using the mesh provided via the INITIAL-MESH argument -- which may be a two element vector containing just the
   x-min and xmax or a VVEC object (See: MJR_VVEC).  It is advantageous to include points of interest for F in :INITIAL-MESH as this may dramatically reduce
   the number of sample points required.  Interesting points include:

     -- Asymptotes. ex: $0$ for $f=\\frac{1}{x^2}$ or $f=\\frac{1}{x}$
     -- Removable discontinuities. ex: $1$ for $f=\\frac{x^2-1}{x-1}$
     -- Jump discontinuities. ex: $\\mathbb{Z}$ for $f=\\mathrm{ceiling}(x)$
     -- Boundaries of undefined regions. ex: $\\pm 1$ for $f=\\sqrt{1-x^2}$ or $f=\\sqrt{x^2-1}$
     -- Infliction points. ex: $0$ for $f=x^3-x$
     -- Extrema. ex: $\\frac{\\pm 1}{\\sqrt{3}}$ for $f=x^3-x$
     -- Roots. ex: $0$ \\& $\\pm 1$ for $f=x^3-x$
     -- Axis intersections. ex: $1$ for $f=(x+1)^2$
     -- Points without a derivative. ex: $0$ for $f=\\vert x\\vert$

   The simplex set is repeatedly refined (i.e. V0--V1 -> V0--VM--V2) until it can no longer be refined.

   A simplex is eligible for refinement if:

     * :MIN-BOUNDING-BOX-WIDTH     :: No edge of the bounding box is less than this value
     * :FINE-MESH-LEVEL            :: Simplex mesh step must be longer than this
     * :MIN-SIMPLEX-LENGTH         :: Simplex must be longer than this

   An eligible simplex is refined if:

     * N/A                          :: V0, VM, or V1 is not defined (is a singularity)
     * :COARSE-MESH-LEVEL           :: Delta T is too big -- this is not depicted in the picture
     * :MAX-SIMPLEX-LENGTH          :: V0--V1 is too long
     * :DO-AXIS-CROSSING            :: V0--V1 crosses the axis
     * :H-CUTOFF-EPS                :: Triangle height (H in the diagram) is too large
     * :SANDWICH-AREA-CUTOFF        :: Area of triangle V0--VM--V1 (A in the diagram) is too large
     * :COS-DIVERGENCE-ANGLE-CUTOFF :: Angle A0 or A1 is too large
     * :COS-JOIN-ANGLE-CUTOFF       :: Angle AM is not near 180 degrees
     * :COS-SMOOTH-ANGLE-CUTOFF     :: Next simplex angle is not near 180 degrees (AS in the diagram), or last simplex was refined for same reason
     * :MAX-BOUNDING-BOX-WIDTH      :: simplex bounding box has an edge longer than this
     * :MAX-BOUNDING-BOX-AREA       :: simplex bounding box has an area larger than this


                                         VM o------------------------------------------------------------o V1                         ---
                                           / .                                                         /  \                            |
                                          /   AM                                             A1     /--    \                           |
                                         /     .                                                 /--        \                          |
                                        /       .                                            /---      AS    \                         |
                                       /         .                                        /--                 \                        |
                                      /           .   H                                /--                     \                       |
                                     /             .                               /---                         \                      |
                                    /               .                           /--                              \                  Bounding
                                   /          A      .                      /---                                  \                    |
                                  /                   .                  /--                                       \                  Box
                                 /                     .              /--                                           \                  |
                                /                       .         /---                                               \               Height
                               /                         .     /--                                                    \                |
                              /                           . /--      V0--V1 :: Unrefined simplex                       \               |
                             /                          /--o VC      V1--V2 :: The next unrefined simplex               \              |
                            /                        /--             V0--VM :: Refined simplex 0                         \             |
                           /                      /--                VM--V1 :: Refined simplex 1                          \            |
                          /                   /---                       A0 :: Angle V1--V0--VM                            o           |
                         /                 /--                           A1 :: Angle V0--V1--VM                             V2         |
                        /              /---                              AM :: Angle V0--VM--V1                                        |
                       /            /--                                  AS :: Angle V0--V1--V2                                        |
                      /   A0     /--                                      A :: Area of triangle V0--VM--V1                             |
                     /       /---                                         H :: Length of VC--VM (which is perpendicular to V0--V1)     |
                    /     /--                                                                                                          |
                   /   /--                                                                                                             |
               V0 o----                                                                                                               ---

                  |-------------------------------------- Bounding Box Width ----------------------------|

  Note: At least one of :FINE-MESH-LEVEL or :MIN-SIMPLEX-LENGTH must be set.

  At the end the mesh is simplified:
     * N/A                 :: If an endpoint of a simplex is a singularity
     * SIMPLIFY-MESH-ANGLE :: If two simplexes are joined at a nearly 180 degree angle

Future

   Add an argument to define 'screen space', and do the refinement tests in this space.  This is useful because angles, areas, and lengths are distorted by
   the sort of scaling typically used to display graphs.  Another reason this is useful is because pixel size is an important factor for final raster images.
   For example we have no good reason fully render objects smaller than pixel, or redraw the same pixel repeatedly.  The :CLIP-MAX & :CLIP-MIN arguments can
   be used to define the plot region, but we must add an argument to describe the screen (:PIXEL-COUNT) which is a vector of pixel counts in each dim.  For 2D
   this will contain two values (X & Y), but it will have 3 for 3D (voxels, not pixels, in this case)."
  (cond ((not (or fine-mesh-level
                  min-simplex-length
                  min-bounding-box-width))                       (error "mjr_fsamp_ds-func-r1-rn-adaptive: Set at least one of:  fine-mesh-level, min-simplex-length, or min-bounding-box-width"))
        ((and clip-max clip-min
              (< clip-max clip-min))                             (error "mjr_fsamp_ds-func-r1-rn-adaptive: clip-max must not be smaller than clip-min"))
        ((and fine-mesh-level coarse-mesh-level
              (< fine-mesh-level coarse-mesh-level))             (error "mjr_fsamp_ds-func-r1-rn-adaptive: fine-mesh-level must not be smaller than coarse-mesh-level"))
        ((and max-simplex-length min-simplex-length
              (< max-simplex-length min-simplex-length))         (error "max-simplex-length  must not be smaller than min-simplex-length"))
        ((and max-bounding-box-width min-bounding-box-width
              (< max-bounding-box-width min-bounding-box-width)) (error "mjr_fsamp_ds-func-r1-rn-adaptive: max-bounding-box-width must not be smaller than min-bounding-box-width"))
        ((and max-bounding-box-area
              (>= 0 max-bounding-box-area))                      (error "mjr_fsamp_ds-func-r1-rn-adaptive: max-bounding-box-area must be positive"))
        ((and cos-join-angle-cutoff
              (>= 0 cos-join-angle-cutoff))                      (error "mjr_fsamp_ds-func-r1-rn-adaptive: cos-join-angle-cutoff must be positive"))
        ((and cos-divergence-angle-cutoff
              (>= 0 cos-divergence-angle-cutoff))                (error "mjr_fsamp_ds-func-r1-rn-adaptive: cos-divergence-angle-cutoff must be positive"))
        ((and h-cutoff-eps
              (>= 0 h-cutoff-eps))                               (error "mjr_fsamp_ds-func-r1-rn-adaptive: h-cutoff-eps must be positive"))
        ((and cos-smooth-angle-cutoff
              (>= 0 cos-smooth-angle-cutoff))                    (error "mjr_fsamp_ds-func-r1-rn-adaptive: cos-smooth-angle-cutoff must be positive"))
        ((and sandwich-area-cutoff
              (>= 0 sandwich-area-cutoff))                       (error "mjr_fsamp_ds-func-r1-rn-adaptive: sandwich-area-cutoff must be positive"))
        ((and simplify-mesh-angle
              (>= 0 simplify-mesh-angle))                        (error "mjr_fsamp_ds-func-r1-rn-adaptive: simplify-mesh-angle must be positive"))
        ((and cos-join-angle-cutoff
              (<= 1 cos-join-angle-cutoff))                      (error "mjr_fsamp_ds-func-r1-rn-adaptive: cos-join-angle-cutoff must be less than 1"))
        ((and cos-divergence-angle-cutoff
              (<= 1 cos-divergence-angle-cutoff))                (error "mjr_fsamp_ds-func-r1-rn-adaptive: cos-divergence-angle-cutoff must be less than 1"))
        ((and cos-smooth-angle-cutoff
              (<= 1 cos-smooth-angle-cutoff))                    (error "mjr_fsamp_ds-func-r1-rn-adaptive: cos-smooth-angle-cutoff must be less than 1"))
        ((and simplify-mesh-angle
              (<= 1 simplify-mesh-angle))                        (error "mjr_fsamp_ds-func-r1-rn-adaptive: simplify-mesh-angle must be less than 1")))
  (progn ;; Warnings
    (if (and cos-join-angle-cutoff
             (<= 0.5 cos-join-angle-cutoff))                      (warn "mjr_fsamp_ds-func-r1-rn-adaptive: cos-join-angle-cutoff must be positive"))
    (if (and cos-divergence-angle-cutoff
             (<= 0.5 cos-divergence-angle-cutoff))                (warn "mjr_fsamp_ds-func-r1-rn-adaptive: cos-divergence-angle-cutoff must be positive"))
    (if (and cos-smooth-angle-cutoff
             (<= 0.5 cos-smooth-angle-cutoff))                    (warn "mjr_fsamp_ds-func-r1-rn-adaptive: cos-smooth-angle-cutoff must be positive"))
    (if (and simplify-mesh-angle
             (<= 0.5 simplify-mesh-angle))                        (warn "mjr_fsamp_ds-func-r1-rn-adaptive: simplify-mesh-angle must be positive")))
  (labels ((fadpt (x) (let ((y (ignore-errors (funcall f x))))
                        (if (= 1 n)
                            (if (and (realp y)
                                     (or (null clip-max) (<= y clip-max))
                                     (or (null clip-min) (>= y clip-min)))
                                (vector x y))
                            (if (and (vectorp y)
                                     (every #'realp y)
                                        (mjr_geom_point-inside-bounding-box-f? y clip-min clip-max))
                                y)))))
    (let* ((max-simplex-length-sq (if max-simplex-length (expt max-simplex-length 2)))
           (min-simplex-length-sq (if min-simplex-length (expt min-simplex-length 2)))
           (initial-mesh       (mjr_vvec_to-vec initial-mesh))
           (xmax               (aref initial-mesh (1- (length initial-mesh))))
           (xmin               (aref initial-mesh 0))
           (coarse-mesh-delta  (if coarse-mesh-level (/ (- xmax xmin) (expt 2 coarse-mesh-level))))
           (fine-mesh-delta    (if fine-mesh-level   (/ (- xmax xmin) (expt 2 fine-mesh-level))))
           (working-state      (loop for i from 2 upto (length initial-mesh) collect -1)) ; -1->bad   1->good -2-> bad because simplex to the left was split due to join angle
           (bad-state-count    (1- (length initial-mesh)))
           (working-t          (map 'list (lambda (x) (float x 1.0d0)) initial-mesh))
           (working-pnt        (map 'list #'fadpt working-t)))
      (if show-progress (format 't "~3@a: ~15@a ~15@a ~15@a ~15@a~%" "i" "Total" "Bad" "Good" "Bad Counter"))
      (loop for i from 0 upto 33
            do (loop with working-loc-state = working-state
                     with working-loc-pnt   = working-pnt
                     with working-loc-t     = working-t
                     for s = (first working-loc-state)
                     do (multiple-value-bind (vm tm)
                            (if (minusp s)
                                (let* ((t0 (first working-loc-t))
                                       (t1 (second working-loc-t))
                                       (td (- t1 t0)))
                                  (if (or (not fine-mesh-delta) (>= td fine-mesh-delta))
                                      (let* ((v0 (first working-loc-pnt))
                                             (v1 (second working-loc-pnt))
                                             (sp (not (and v0 v1)))
                                             (v2 (third working-loc-pnt))
                                             (tm (/ (+ t0 t1) 2.0d0))
                                             (vm (fadpt tm))
                                             (bbw (if (or max-bounding-box-width max-bounding-box-area min-bounding-box-width) (mjr_geom_bounding-widths v0 v1))))
                                        (if (and (or (not min-simplex-length-sq) (and (< min-simplex-length-sq (mjr_geom_distance-euclidean-squared v0 vm))
                                                                                      (< min-simplex-length-sq (mjr_geom_distance-euclidean-squared v1 vm))))
                                                 (or (not min-bounding-box-width) (every (lambda (x) (>= x min-bounding-box-width)) bbw)))
                                            (if (or
                                                 sp                                                                                                          ;; Origonal simplex was special
                                                 (null vm)                                                                                                   ;; New simplex is special
                                                 (and coarse-mesh-delta (>= td coarse-mesh-delta))                                                           ;; x-delta is bigger than coarse-mesh
                                                 (and max-simplex-length-sq (> (mjr_geom_distance-euclidean-squared v0 v1) max-simplex-length-sq))           ;; Simplex too long
                                                 (and do-axis-crossing (some #'minusp (map 'list (lambda (a b) (* (signum a) (signum b))) v0 v1)))           ;; axis crossing
                                                 (and cos-divergence-angle-cutoff (< (mjr_geom_tri-cos-angle-f vm v0 v1) (- 1 cos-divergence-angle-cutoff))) ;; left angle too big
                                                 (and cos-divergence-angle-cutoff (< (mjr_geom_tri-cos-angle-f vm v1 v0) (- 1 cos-divergence-angle-cutoff))) ;; right angle too big
                                                 (and cos-join-angle-cutoff       (> (mjr_geom_tri-cos-angle-f v1 vm v0) (- cos-join-angle-cutoff 1)))       ;; center angle not near 180
                                                 (and max-bounding-box-width (some (lambda (x) (> (abs x) max-bounding-box-width)) bbw))                     ;; unrefined simplex bb area too large
                                                 (and max-bounding-box-area  (> (reduce #'* bbw) max-bounding-box-area))                                     ;; unrefined simplex bb side too long
                                                 (if (and cos-smooth-angle-cutoff v2 v2)                                                                     ;; is next simplex has steep angle
                                                     (let ((old-cos-angle (mjr_geom_tri-cos-angle-f v0 v1 v2))
                                                           (new-cos-angle (mjr_geom_tri-cos-angle-f vm v1 v2)))
                                                       (if (and (> old-cos-angle (- cos-smooth-angle-cutoff 1))
                                                                (> old-cos-angle new-cos-angle))
                                                           (progn (if (plusp (second working-loc-state)) (incf bad-state-count))
                                                                  (setf (second working-loc-state) -2)))))
                                                 (and cos-smooth-angle-cutoff (= -2 s))                                                                      ;; last simplex was cut for smoothness
                                                 (if (or h-cutoff-eps sandwich-area-cutoff)
                                                     (let ((a (mjr_geom_simplex-area v0 vm v1)))
                                                       (or  (and sandwich-area-cutoff (> a sandwich-area-cutoff))                                            ;; Area between old and new simplex
                                                            (and h-cutoff-eps (> (/ (* 2 a) (mjr_geom_distance-euclidean-squared v0 v1)) h-cutoff-eps))))))  ;; New vertex is too far away from origonal simplex
                                                (values vm tm)))))))
                          (if tm
                              (progn (push vm  (cdr working-loc-pnt))
                                     (push -1  (cdr working-loc-state))
                                     (push tm  (cdr working-loc-t))
                                     (incf bad-state-count)
                                     (if (= -2 s) (setf (first working-loc-state) -1))
                                     (setf working-loc-state (cddr working-loc-state))
                                     (setf working-loc-pnt   (cddr working-loc-pnt))
                                     (setf working-loc-t     (cddr working-loc-t)))
                              (progn (setf (first working-loc-state) 1)
                                     (if (minusp s) (decf bad-state-count))
                                     (setf working-loc-state (cdr working-loc-state))
                                     (setf working-loc-pnt   (cdr working-loc-pnt))
                                     (setf working-loc-t     (cdr working-loc-t)))))
                     while (cdr working-loc-pnt))
            do (if show-progress (format 't "~3d: ~15d ~15d ~15d ~15d~%" i (length working-state) (count-if #'minusp working-state) (count-if #'plusp working-state) bad-state-count))
            while (not (zerop bad-state-count)))
      (if show-progress (let ((pnt-cnt (length working-pnt))
                              (sng-pnt-cnt (count-if (lambda (v) (or (null v) (null (aref v 1)))) working-pnt)))
                          (format 't "Sample Points ............. ~d~%" pnt-cnt)
                          (format 't "Nonsingular Points ........ ~d~%" (- pnt-cnt sng-pnt-cnt))
                          (format 't "Singular Points ........... ~d~%" sng-pnt-cnt)))
      (let ((good-pnt        nil)
            (good-pnt-size   0)
            (good-edges      nil)
            (good-edges-size 0))
        (if simplify-mesh-angle
            (loop with first-on-pnt-list = nil
                  with v0 = nil
                  with v1 = nil
                  do (setf v0 (loop for vc = (pop working-pnt)
                                    when (or (and vc (aref vc 1)) (null working-pnt))
                                    do (return vc)))
                  while v0
                  do (setf v1 (first working-pnt))
                  do (if (or (null v1) (null (aref v1 1)))
                         (setf first-on-pnt-list nil)
                         (progn (loop for v2 = (second working-pnt)
                                      while (and v2 (aref v2 1) (> (mjr_geom_tri-cos-angle-f v1 v0 v2) (- 1 simplify-mesh-angle)))
                                      do (pop working-pnt))
                                (setf v1 (first working-pnt))
                                (if (not first-on-pnt-list)
                                    (progn (push v0 good-pnt)
                                           (incf good-pnt-size)))
                                (push v1 good-pnt)
                                (incf good-pnt-size)
                                (push (vector (- good-pnt-size 2) (- good-pnt-size 1)) good-edges)
                                (incf good-edges-size)
                                (setq first-on-pnt-list 't))))
            (loop with pushed-last = nil
                  for v0 = (first working-pnt) then v1
                  for v1 in (cdr working-pnt)
                  do (if (not (some #'null (list v0 v1)))
                         (progn (if (not pushed-last)
                                    (progn (push v0 good-pnt)
                                           (incf good-pnt-size)))
                                (setf pushed-last 't)
                                (push v1 good-pnt)
                                (incf good-pnt-size)
                                (push (vector (- good-pnt-size 2) (- good-pnt-size 1)) good-edges)
                                (incf good-edges-size))
                         (setf pushed-last nil))))
        (if show-progress (format 't "Final Sample Point Count .. ~d~%" good-pnt-size))
        (if show-progress (format 't "Final Simplex Count ....... ~d~%" good-edges-size))
        (list '(0 0 0 0)
              (make-array good-pnt-size :initial-contents (reverse good-pnt))
              (make-array good-edges-size   :initial-contents (reverse good-edges))
              nil
              nil)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
;; (defun mjr_fsamp_ds-implicit-r2-adaptive (...)
;;
;; The normal use case is to graph an implicitly defined curve in $\mathbb{R}^2$
;;
;; Given a function $f:\mathbb{R}^2\rightarrow\mathbb{R}$.  Let $P = \{x\in\mathbb{R}^2 \vert f(x)>0\}$ and $N = \{x\in\mathbb{R}^2 \vert f(x)<0\}$.  This
;; function attempts to find the boundary between these two sets (which, for God fearing functions, is the set where $f(x)=0$).  This works by finding short
;; line segments with one end in $P$ and the other end in $N$, so the function must have regions above and below the $xy$ plain.  For example, the zero sets
;; of $f(x,y)=x^2+y^2-1$ and $g(x,y)=(x^2+y^2-1)^2$ are both the unit circle centered at zero; however, this function will work for $f$ but not for $g$.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
;; (defun mjr_fsamp_ds-implicit-r3-adaptive (...)
;;
;; The normal use case is to graph an implicitly defined curve in $\mathbb{R}^3$

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO 
;; (defun mjr_fsamp_bq-func-r2-r1-adaptive (f &key
;;                                            (n                           1)   ;; dimintion of return from f
;;                                            (clip-max                    nil) ;; Bounding box minimum. Set to throw out points
;;                                            (clip-min                    nil) ;; Bounding box maximm. Set to throw out points
;;                                            (fine-mesh-level             10)  ;; Set finest mesh width to (expt 2 fine-mesh-level)/range
;;                                            (coarse-mesh-level           4)   ;; Set corsest mesh width to (expt 2 fine-mesh-level)/range
;;                                            (max-simplex-length          nil) ;; (max-min)/100
;;                                            (min-simplex-length          nil) ;; (max-min)/10000
;;                                            (max-bounding-box-width      nil)
;;                                            (min-bounding-box-width      nil) ;; May be more usefull than min-simplex-length
;;                                            (max-bounding-box-area       nil)
;;                                            (cos-join-angle-cutoff       nil) ;; 0.0001d0
;;                                            (cos-divergence-angle-cutoff nil) ;; 0.0001d0 => just less than 1 degree
;;                                            (h-cutoff-eps                nil) ;; 0.01d0
;;                                            (cos-smooth-angle-cutoff     nil) ;; 0.0001d0
;;                                            (sandwich-area-cutoff        nil) ;;
;;                                            (do-axis-crossing            nil)
;;                                            (simplify-mesh-angle         nil) ;; 0.0001d0
;;                                            (show-progress               nil))
;; Given a function $f:\mathbb{R}^2\rightarrow\mathbb{R}$.  Sample function adaptively and store data in a BQTREE.
                                                                                                           
