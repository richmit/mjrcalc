;; -*- Mode:Lisp; Syntax:ANSI-Common-LISP; Coding:us-ascii-unix; fill-column:132 -*-
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;; @file      utst-plot.lisp
;; @author    Mitch Richling <http://www.mitchr.me>
;; @Copyright Copyright 2015 by Mitch Richling.  All rights reserved.
;; @brief     Tests for :MJR_PLOT.@EOL
;; @Keywords  tests
;; @Std       Common Lisp
;;
;;            TODO: Add tests for parametric surfaces.
;;            

;;----------------------------------------------------------------------------------------------------------------------------------

(defvar t1) (setq t1 (mjr_vec_make-seq :start 0 :end 7.0 :len 10))
(defvar x1) (setq x1 (mjr_vec_ewuo t1 (lambda (x) (* x (cos x)))))
(defvar y1) (setq y1 (mjr_vec_ewuo t1 (lambda (x) (* x (sin x)))))
(defvar z1) (setq z1 (mjr_vec_ewuo t1 (lambda (x) (* x (sin (* 2 x))))))
(defvar x2) (setq x2 (mjr_vec_ewuo t1 (lambda (x) (* x (- (cos x))))))
(defvar y2) (setq y2 (mjr_vec_ewuo t1 (lambda (x) (* x (- (sin x))))))
(defvar z2) (setq z2 (mjr_vec_ewuo t1 (lambda (x) (* x (- (sin (* 2 x)))))))
(defvar xy) (setq xy (mjr_vec_ewuo t1 (lambda (x) (complex (* x (- (cos x))) (* x (- (sin x)))))))
(defvar t2) (setq t2 (mjr_vec_make-seq :start 0 :end 7.0 :len 50))
(defvar x3) (setq x3 (mjr_vec_ewuo t2 (lambda (x) (* x (- (cos x))))))
(defvar y3) (setq y3 (mjr_vec_ewuo t2 (lambda (x) (* x (- (sin x))))))
(defvar z3) (setq z3 (mjr_vec_ewuo t2 (lambda (x) (* x (- (sin (* 2 x)))))))
(defvar m ) (setq m  (mjr_arr_cbind t1 x1 y1 z1 x2 y2 z2))
(defvar m2) (setq m2 (mjr_arr_cbind t2 x3 y3 z3))
(defvar m3) (setq m3 (mjr_arr_cbind t1 xy x1 y1))
(defvar x5) (setq x5 (mjr_vec_make-seq :start -8 :end 8 :len 4))
(defvar y5) (setq y5 (mjr_vec_make-seq :start -8 :end 8 :len 4))
(defvar z5) (setq z5 (mjr_mat_make-from-func (lambda (i j) (+ 0.3 (+ (abs i) (abs j)))) :rows 4 :cols 4 :rstart -8 :cstart -8 :rend 8 :cend 8))
(defvar z6) (setq z6 (mjr_mat_make-from-func (lambda (i j) (- 0.3 (+ (abs i) (abs j)))) :rows 4 :cols 4 :rstart -8 :cstart -8 :rend 8 :cend 8))
(defvar m4) (setq m4 (mjr_mat_make-table (lambda (x y) (list (+ 0.3 (+ (abs x) (abs y))) (- 0.3 (+ (abs x) (abs y))))) :start -8 :end 8 :len 4 :n 2))
(defvar m5) (setq m5 (mjr_mat_make-table (lambda (x y) (list (+ 0.3 (+ (abs x) (abs y))))) :start -8 :end  8 :len  4 :n 2))
(defvar m6) (setq m6 (mjr_mat_make-table (lambda (x y) (list (- 0.3 (+ (abs x) (abs y))))) :start -8 :end  8 :len 10 :n 2))
(defvar m7) (setq m7 (mjr_mat_make-table (lambda (x y) (list (+ 0.3 (+ (abs x) (abs y))))) :start -8 :end -1 :len  4 :n 2))
(defvar m8) (setq m8 (mjr_mat_make-table (lambda (x y) (list (- 0.3 (+ (abs x) (abs y))))) :start  1 :end  8 :len 10 :n 2))


; Sequence tests
(print "one curve (growing sin wave)")
(mjr_plot_data                                       :ydat y1)
(read-char)
(print "one curve (swrl)")
(mjr_plot_data :xdat x1                              :ydat y1)
(read-char)
(print "two curve (black=right/left=red))")
(mjr_plot_data :xdat (list x1 x2)                    :ydat y1)
(read-char)
(print "two curve (red=top/bot=black)")
(mjr_plot_data :xdat x1                              :ydat (list y1 y2))
(read-char)
(print "two curve (spiral) right most black")
(mjr_plot_data :xdat (list x1 x2 )                   :ydat (list y1 y2))
(read-char)
(print "3D:one curve")
(mjr_plot_data :xdat x1                              :ydat y1                      :zdat z1)
(read-char)
(print "3D:two curve")
(mjr_plot_data :xdat (list x1 x2)                    :ydat y1                      :zdat z1)
(read-char)
(print "3D:two curve 2")
(mjr_plot_data :xdat x1                              :ydat (list y1 y2)            :zdat z1)
(read-char)
(print "3D:two curve (spiral)")
(mjr_plot_data :xdat (list x1 x2 )                   :ydat (list y1 y2)            :zdat z1)
(read-char)
(print "3D:two curve (spiral) with z dif.")
(mjr_plot_data :xdat (list x1 x2 )                   :ydat (list y1 y2)            :zdat (list z1 z2))
(read-char)
(print "two curve (spiral) right black. Red is smooth ")
(mjr_plot_data :xdat (list x1 x3 )                   :ydat (list y1 y3))
(read-char)


; Data transform
(print "one curve (swrl)")
(mjr_plot_data :xdat (list #'imagpart :ydat)         :ydat (list #'realpart xy))
(read-char)
(print "one curve (growing negative sine)")
(mjr_plot_data :xdat t1                              :ydat (list #'realpart xy))
(read-char)
(print "one curve (growing sine integer x-axis)")
(mjr_plot_data                                       :ydat (list #'realpart xy))
(read-char)
(print "one curve (spiral CCW)")
(mjr_plot_data :xdat (list (list #'realpart :ydat))  :ydat (list (list #'imagpart xy)))
(read-char)
(print "one curve (spiral CW)")
(mjr_plot_data :xdat (list (list #'imagpart :ydat))  :ydat (list #'realpart xy))
(read-char)
(print "one curve (sine curve no damp)")
(mjr_plot_data :xdat t1                              :ydat  (list #'sin :xdat))
(read-char)


; Matrix data
(print "DAT:one curve (growing sin wave)")
(mjr_plot_data :dat m             :datcols 1)
(read-char)
(print "DAT:one curve (swrl)")
(mjr_plot_data :dat m             :datcols #(1 2))
(read-char)
(print "DAT:two curve (black=right/left=red))")
(mjr_plot_data :dat m             :datcols (list #(1 2) #(4 2)))
(read-char)
(print "DAT:two curve (red=top/bot=black)")
(mjr_plot_data :dat m             :datcols (list #(1 2) #(1 5)))
(read-char)
(print "DAT:two curve (spiral) right most black")
(mjr_plot_data :dat m             :datcols (list #(1 2) #(4 5)))
(read-char)
(print "DAT:3D:one curve")
(mjr_plot_data :dat m             :datcols (list #(1 2 3)))
(read-char)
(print "DAT:3D:two curve")
(mjr_plot_data :dat m             :datcols (list #(1 2 3) #(4 2 3)))
(read-char)
(print "DAT:3D:two curve 2")
(mjr_plot_data :dat m             :datcols (list #(1 2 3) #(1 5 3)))
(read-char)
(print "DAT:3D:two curve (spiral)")
(mjr_plot_data :dat m             :datcols (list #(1 2 3) #(4 5 3)))
(read-char)
(print "DAT:3D:two curve (spiral) with z dif.")
(mjr_plot_data :dat m             :datcols (list #(1 2 3) #(4 5 6)))
(read-char)
(print "DAT:3D:two curve 2.  Black curve smooth.")
(mjr_plot_data :dat (list m2 m )  :datcols (list #(1 2 3) #(1 5 3)))
(read-char)


; Transformed matrix data
(print "DAT:one curve (slanted swrl, high res)")
(mjr_plot_data :dat m2            :datcols '((+ 1 2) 2))
(read-char)
(print "DAT:one curve (swrl CCW)")
(mjr_plot_data :dat m3            :datcols '((realpart 1) (imagpart 1)))
(read-char)
(print "DAT:one curve (swrl CW)")
(mjr_plot_data :dat m3            :datcols (list (list (lambda (x) (imagpart x)) 1) (list #'realpart 1)))
(read-char)
(print "DAT:one curve (swrl CCW)")
(mjr_plot_data :dat m3            :datcols (list (list (lambda (x) (realpart x)) 1) '(imagpart 1)))
(read-char)
(print "DAT:one curve (swrl CW)")
(mjr_plot_data :dat m3            :datcols (list (list #'imagpart 1) (list #'realpart 1)))
(read-char)
(print "DAT:two curve (red swrl CCW, black swrl CW)")
(mjr_plot_data :dat m3            :datcols (list (list 2 3) (list (list #'imagpart 1) (list #'realpart 1))))


; Surface (2dof) plots with :(x|y|z)dat
(print "1 surf, down")
(mjr_plot_data :type :f :zdat z5 :span -1)
(read-char)
(print "1 surf, down, with axis ranges [-8,8]")
(mjr_plot_data :type :f  :xdat x5 :ydat y5 :zdat z5 :span -1)
(read-char)
(print "1 surf, down, with axis ranges [-8,8], 2 curve, green in z=0 pln")
(mjr_plot_data :type (list :l :l :l)  :xdat (list x5 x1 x1) :ydat (list y5 y1 y1) :zdat (list z5 z1 nil) :span (list 0 nil nil))
(read-char)
(print "2 surf, down + up")
(mjr_plot_data :type :f  :zdat (list z5 z6) :span -1)
(read-char)


; Surface (2dof) plots with :dat
(print "1 surf, down")
(mjr_plot_data :type :f :datcols #(0 1 2) :span 4 :dat m4)
(read-char)
(print "1 surf, up")
(mjr_plot_data :type :f :datcols #(0 1 3) :span 4 :dat m4)
(read-char)
(print "2 surf, down + up")
(mjr_plot_data :type :f :datcols (list #(0 1 2) #(0 1 3)) :span 4 :dat m4)
(read-char)
(print "2 surf, down + up, up has 10x10 grid, down has 4x4 grid")
(mjr_plot_data :type :f :datcols #(0 1 2) :span (list 4 10) :dat (list m5 m6))
(read-char)
(print "2 IMAGES, down + up, up has 10x10 grid, down has 4x4 grid, up is in upper left, down is in lower right")
(mjr_plot_data :type :i :datcols #(0 1 2) :span (list 4 10) :dat (list m7 m8))
(read-char)
(print "2 surfaces, down + up, up has 10x10 grid, down has 4x4 grid, up is in positive x-y quadrant")
(mjr_plot_data :type :f :datcols #(0 1 2) :span (list 4 10) :dat (list m7 m8))



;;(mjr_plot_func-r1-r2 (lambda (u) (vector (sin u) (cos u) u)) :udat '(:start .3 :end 6.0 :len 100))
